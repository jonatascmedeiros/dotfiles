# !/bin/bash
#
# Architect Installation Framework (version 2.3.1 - 26-Mar-2016)
#
# Written by Carl Duff for Architect Linux
#
# This program is free software, provided under the GNU General Public License
# as published by the Free Software Foundation. So feel free to copy, distribute,
# or modify it as you wish.
#



######################################################################
##																	##
##                   Installer Variables							##
##																	##
######################################################################

# Temporary files to store menu selections
ANSWER="/tmp/.aif"				# Basic menu selections
PACKAGES="/tmp/.pkgs"			# Packages to install
MOUNT_OPTS="/tmp/.mnt_opts" 	# Filesystem Mount options

# Save retyping
VERSION="Architect Installation Framework 2.3.1"

# Installation
DM_INST=""							# Which DMs have been installed?
DM_ENABLED=0						# Has a display manager been enabled?
NM_INST=""							# Which NMs have been installed?
NM_ENABLED=0						# Has a network connection manager been enabled?
KERNEL="n"                			# Kernel(s) installed (base install); kernels for mkinitcpio
GRAPHIC_CARD=""						# graphics card
INTEGRATED_GC=""					# Integrated graphics card for NVIDIA
NVIDIA_INST=0         				# Indicates if NVIDIA proprietary driver has been installed
NVIDIA=""							# NVIDIA driver(s) to install depending on kernel(s)
VB_MOD=""							# headers packages to install depending on kernel(s)
SHOW_ONCE=0           				# Show de_wm information only once
COPY_PACCONF=0						# Copy over installer /etc/pacman.conf to installed system?

# Mounting
MOUNTPOINT="/mnt"       			# Installation: Root mount
MOUNT=""							# Installation: All other mounts branching from Root
FS_OPTS=""							# File system special mount options available
CHK_NUM=16							# Used for FS mount options checklist length
INCLUDE_PART='part\|lvm\|crypt'		# Partition types to include for display and selection.
ROOT_PART=""          				# ROOT partition
UEFI_PART=""						# UEFI partition
UEFI_MOUNT=""         				# UEFI mountpoint (/boot or /boot/efi)

# Architecture
ARCHI=$(uname -m)     				# Display whether 32 or 64 bit system

# Menu highlighting (automated step progression)
HIGHLIGHT=0           				# Highlight items for Main Menu
HIGHLIGHT_SUB=0	    				# Highlight items for submenus
SUB_MENU=""           				# Submenu to be highlighted

# Locale and Language
CURR_LOCALE="en_US.UTF-8"   		# Default Locale
FONT=""                     		# Set new font if necessary
KEYMAP="us"          				# Virtual console keymap. Default is "us"
XKBMAP="us"      	    			# X11 keyboard layout. Default is "us"
ZONE=""               				# For time
SUBZONE=""            				# For time
LOCALE="en_US.UTF-8"  				# System locale. Default is "en_US.UTF-8"


# Edit Files
FILE=""                     		# File(s) to be reviewed

######################################################################
##																	##
##                        Core Functions							##
##																	##
######################################################################

select_language()
{
	source /aif-master/english.trans
	CURR_LOCALE="en_US.UTF-8"
        
    # Generate the chosen locale and set the language
    sed -i "s/#${CURR_LOCALE}/${CURR_LOCALE}/" /etc/locale.gen
    locale-gen >/dev/null 2>&1
    export LANG=${CURR_LOCALE}
    [[ $FONT != "" ]] && setfont $FONT
}

# Check user is root, and that there is an active internet connection
# Seperated the checks into seperate "if" statements for readability.
check_requirements()
{
	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ChkTitle " --infobox "$_ChkBody" 0 0
	sleep 2
  
	if [[ `whoami` != "root" ]]; then
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_Erritle " --infobox "$_RtFailBody" 0 0
		sleep 2
		exit 1
	fi
  
	if [[ ! $(ping -c 1 google.com) ]]; then
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ErrTitle " --infobox "$_ConFailBody" 0 0
		sleep 2
		exit 1
	fi
  
	# This will only be executed where neither of the above checks are true.
	# The error log is also cleared, just in case something is there from a previous use of the installer.
	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ReqMetTitle " --infobox "$_ReqMetBody" 0 0
	sleep 2   
	clear
	echo "" > /tmp/.errlog
	pacman -Syy
}

id_system() 
{
	modprobe -q efivarfs            
	# Mount efivarfs if it is not already mounted
	if [[ -z $(mount | grep /sys/firmware/efi/efivars) ]]; then
		mount -t efivarfs efivarfs /sys/firmware/efi/efivars
	fi
}   

# Adapted from AIS. An excellent bit of code!
arch_chroot()
{
    arch-chroot $MOUNTPOINT /bin/bash -c "${1}"
}  

# If there is an error, display it, clear the log and then go back to the main menu (no point in continuing).
check_for_error()
{
	if [[ $? -eq 1 ]] && [[ $(cat /tmp/.errlog | grep -i "error") != "" ]]; then
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ErrTitle " --msgbox "$(cat /tmp/.errlog)" 0 0
		echo "" > /tmp/.errlog
		main_menu_online
	fi
}

# Ensure that a partition is mounted
check_mount() 
{
	if [[ $(lsblk -o MOUNTPOINT | grep ${MOUNTPOINT}) == "" ]]; then
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ErrTitle " --msgbox "$_ErrNoMount" 0 0
		main_menu_online
    fi
}

# Ensure that Arch has been installed
check_base()
{
    if [[ ! -e ${MOUNTPOINT}/etc ]]; then
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ErrTitle " --msgbox "$_ErrNoBase" 0 0
        main_menu_online
    fi
}

######################################################################
##																	##
##                 Configuration Functions							##
##																	##
######################################################################

# Originally adapted from AIS. Added option to allow users to edit the mirrorlist.
configure_mirrorlist() 
{

	# Generate a mirrorlist based on the country chosen.	
	mirror_by_country()
	{
		URL="https://www.archlinux.org/mirrorlist/?country=BR&use_mirror_status=on"
		MIRROR_TEMP=$(mktemp --suffix=-mirrorlist)

		# Get latest mirror list and save to tmpfile
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_MirrorlistTitle " --infobox "$_PlsWaitBody" 0 0
  
		curl -so ${MIRROR_TEMP} ${URL} 2>/tmp/.errlog
		check_for_error
		sed -i 's/^#Server/Server/g' ${MIRROR_TEMP}
		vi ${MIRROR_TEMP}

		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_MirrorlistTitle " --yesno "$_MirrorGenQ" 0 0

		if [[ $? -eq 0 ]];then
			mv -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.orig
			mv -f ${MIRROR_TEMP} /etc/pacman.d/mirrorlist
			chmod +r /etc/pacman.d/mirrorlist
			dialog --backtitle "$VERSION - ($ARCHI)" --title " $_MirrorlistTitle " --infobox "\n$_Done!\n\n" 0 0
			sleep 2
		else
			configure_mirrorlist
		fi
	}

	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_MirrorlistTitle " \
    --menu "$_MirrorlistBody" 0 0 6 \
	"1" "$_MirrorbyCountry" \
	"2" "$_MirrorRankTitle" \
	"3" "$_MirrorEdit" \
	"4" "$_MirrorRestTitle" \
	"5" "$_MirrorPacman" \
	"6" "$_Back" 2>${ANSWER}	

    case $(cat ${ANSWER}) in
        "1") mirror_by_country
             ;;
        "2") dialog --backtitle "$VERSION - ($ARCHI)" --title " $_MirrorlistTitle " --infobox "$_MirrorRankBody $_PlsWaitBody" 0 0
             cp -f /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.backup
             rankmirrors -n 6 /etc/pacman.d/mirrorlist.backup > /etc/pacman.d/mirrorlist 2>/tmp/.errlog
             check_for_error
             dialog --backtitle "$VERSION - ($ARCHI)" --title " $_MirrorlistTitle " --infobox "\n$_Done!\n\n" 0 0
			 sleep 2
             ;;
        "3") vi /etc/pacman.d/mirrorlist
             ;;
        "4") if [[ -e /etc/pacman.d/mirrorlist.orig ]]; then       
				 mv -f /etc/pacman.d/mirrorlist.orig /etc/pacman.d/mirrorlist
				 dialog --backtitle "$VERSION - ($ARCHI)" --title " $_MirrorlistTitle " --msgbox "\n$_Done!\n\n" 0 0
			 else
		         dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ErrTitle " --msgbox "$_MirrorNoneBody" 0 0
		     fi
             ;;
        "5") cp pacman.conf /etc/
			 dialog --backtitle "$VERSION - ($ARCHI)" --title " $_MirrorPacman " --yesno "$_MIrrorPacQ" 0 0 && COPY_PACCONF=1 || COPY_PACCONF=0
			 pacman -Syy
			 ;;
		*)   install_base_menu
             ;;
    esac  	

    configure_mirrorlist
}

# Set keymap for X11
set_xkbmap()
{
	XKBMAP_LIST=""
	keymaps_xkb=("af al am at az ba bd be bg br bt bw by ca cd ch cm cn cz de dk ee es et eu fi fo fr gb ge gh gn gr hr hu ie il in iq ir is it jp ke kg kh kr kz la lk lt lv ma md me mk ml mm mn mt mv ng nl no np pc ph pk pl pt ro rs ru se si sk sn sy tg th tj tm tr tw tz ua us uz vn za")
    
	for i in ${keymaps_xkb}; do
        XKBMAP_LIST="${XKBMAP_LIST} ${i} -"
    done
	
    dialog --backtitle "$VERSION - ($ARCHI)" --title " $_PrepKBLayout " --menu "$_XkbmapBody" 0 0 16 ${XKBMAP_LIST} 2>${ANSWER} || install_graphics_menu
    XKBMAP=$(cat ${ANSWER} |sed 's/_.*//')
    echo -e "Section "\"InputClass"\"\nIdentifier "\"system-keyboard"\"\nMatchIsKeyboard "\"on"\"\nOption "\"XkbLayout"\" "\"${XKBMAP}"\"\nEndSection" > ${MOUNTPOINT}/etc/X11/xorg.conf.d/00-keyboard.conf
}

# locale array generation code adapted from the Manjaro 0.8 installer
set_locale()
{
	LOCALES=""	
	for i in $(cat /etc/locale.gen | grep -v "#  " | sed 's/#//g' | sed 's/ UTF-8//g' | grep .UTF-8); do
	  LOCALES="${LOCALES} ${i} -"
	done

	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ConfBseSysLoc " --menu "$_localeBody" 0 0 12 ${LOCALES} 2>${ANSWER} || config_base_menu 
	LOCALE=$(cat ${ANSWER})

	echo "LANG=\"${LOCALE}\"" > ${MOUNTPOINT}/etc/locale.conf
	sed -i "s/#${LOCALE}/${LOCALE}/" ${MOUNTPOINT}/etc/locale.gen 2>/tmp/.errlog
	arch_chroot "locale-gen" >/dev/null 2>>/tmp/.errlog
	check_for_error
}

# Set Zone and Sub-Zone
set_timezone() 
{
    ZONE=""
    for i in $(cat /usr/share/zoneinfo/zone.tab | awk '{print $3}' | grep "/" | sed "s/\/.*//g" | sort -ud); do
		ZONE="$ZONE ${i} -"
    done
    
	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ConfBseTimeHC " --menu "$_TimeZBody" 0 0 10 ${ZONE} 2>${ANSWER} || config_base_menu
    ZONE=$(cat ${ANSWER}) 
    
    SUBZONE=""
    for i in $(cat /usr/share/zoneinfo/zone.tab | awk '{print $3}' | grep "${ZONE}/" | sed "s/${ZONE}\///g" | sort -ud); do
		SUBZONE="$SUBZONE ${i} -"
    done
         
    dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ConfBseTimeHC " --menu "$_TimeSubZBody" 0 0 11 ${SUBZONE} 2>${ANSWER} || config_base_menu
    SUBZONE=$(cat ${ANSWER}) 
    
    dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ConfBseTimeHC " --yesno "$_TimeZQ ${ZONE}/${SUBZONE}?" 0 0 
     
    if [[ $? -eq 0 ]]; then
        arch_chroot "ln -s /usr/share/zoneinfo/${ZONE}/${SUBZONE} /etc/localtime" 2>/tmp/.errlog
        check_for_error
    else
        config_base_menu
    fi
}

set_hw_clock()
{
	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ConfBseTimeHC " --menu "$_HwCBody" 0 0 2 \
 	"utc" "-" "localtime" "-" 2>${ANSWER}	

    [[ $(cat ${ANSWER}) != "" ]] && arch_chroot "hwclock --systohc --$(cat ${ANSWER})"  2>/tmp/.errlog && check_for_error
}

# Function will not allow incorrect UUID type for installed system.
generate_fstab() 
{
    dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ConfBseFstab " --menu "$_FstabBody" 0 0 2 \
	"genfstab -U -p" "$_FstabDevUUID" \
	"genfstab -t PARTUUID -p" "$_FstabDevPtUUID" 2>${ANSWER}
	
	if [[ $(cat ${ANSWER}) != "" ]]; then
		$(cat ${ANSWER}) ${MOUNTPOINT} > ${MOUNTPOINT}/etc/fstab 2>/tmp/.errlog
		check_for_error
	fi
	
	config_base_menu
}

set_hostname() 
{
	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ConfBseHost " --inputbox "$_HostNameBody" 0 0 "arch" 2>${ANSWER} || config_base_menu

	echo "$(cat ${ANSWER})" > ${MOUNTPOINT}/etc/hostname 2>/tmp/.errlog
	echo -e "#<ip-address>\t<hostname.domain.org>\t<hostname>\n127.0.0.1\tlocalhost.localdomain\tlocalhost\t$(cat ${ANSWER})\n::1\tlocalhost.localdomain\tlocalhost\t$(cat ${ANSWER})" > ${MOUNTPOINT}/etc/hosts 2>>/tmp/.errlog
	check_for_error
}

# Adapted and simplified from the Manjaro 0.8 and Antergos 2.0 installers
set_root_password() 
{
    dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ConfUsrRoot " --clear --insecure --passwordbox "$_PassRtBody" 0 0 2> ${ANSWER} || config_base_menu
    PASSWD=$(cat ${ANSWER})
    
    dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ConfUsrRoot " --clear --insecure --passwordbox "$_PassReEntBody" 0 0 2> ${ANSWER} || config_base_menu
    PASSWD2=$(cat ${ANSWER})
    
    if [[ $PASSWD == $PASSWD2 ]]; then 
		echo -e "${PASSWD}\n${PASSWD}" > /tmp/.passwd
		arch_chroot "passwd root" < /tmp/.passwd >/dev/null 2>/tmp/.errlog
		rm /tmp/.passwd
		check_for_error
    else
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ErrTitle " --msgbox "$_PassErrBody" 0 0
		set_root_password
    fi
}

# Originally adapted from the Antergos 2.0 installer
create_new_user() 
{
	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_NUsrTitle " --inputbox "$_NUsrBody" 0 0 "" 2>${ANSWER} || config_base_menu
	USER=$(cat ${ANSWER})
	
	# Loop while user name is blank, has spaces, or has capital letters in it.
	while [[ ${#USER} -eq 0 ]] || [[ $USER =~ \ |\' ]] || [[ $USER =~ [^a-z0-9\ ] ]]; do
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_NUsrTitle " --inputbox "$_NUsrErrBody" 0 0 "" 2>${ANSWER} || config_base_menu
		USER=$(cat ${ANSWER})
	done
	
	# Enter password. This step will only be reached where the loop has been skipped or broken.
	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ConfUsrNew " --clear --insecure --passwordbox "$_PassNUsrBody $USER\n\n" 0 0 2> ${ANSWER} || config_base_menu
	PASSWD=$(cat ${ANSWER}) 

	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ConfUsrNew " --clear --insecure --passwordbox "$_PassReEntBody" 0 0 2> ${ANSWER} || config_base_menu
	PASSWD2=$(cat ${ANSWER}) 

	# loop while passwords entered do not match.
	while [[ $PASSWD != $PASSWD2 ]]; do
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ErrTitle " --msgbox "$_PassErrBody" 0 0
		  
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ConfUsrNew " --clear --insecure --passwordbox "$_PassNUsrBody $USER\n\n" 0 0 2> ${ANSWER} || config_base_menu
		PASSWD=$(cat ${ANSWER}) 

		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ConfUsrNew " --clear --insecure --passwordbox "$_PassReEntBody" 0 0 2> ${ANSWER} || config_base_menu
		PASSWD2=$(cat ${ANSWER}) 
	done      

	# create new user. This step will only be reached where the password loop has been skipped or broken.  
	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ConfUsrNew " --infobox "$_NUsrSetBody" 0 0
	sleep 2
	# Create the user, set password, then remove temporary password file
	arch_chroot "useradd ${USER} -m -g users -G wheel,storage,power,network,video,audio,lp -s /bin/bash" 2>/tmp/.errlog
	check_for_error
	echo -e "${PASSWD}\n${PASSWD}" > /tmp/.passwd
	arch_chroot "passwd ${USER}" < /tmp/.passwd >/dev/null 2>/tmp/.errlog
	rm /tmp/.passwd
	check_for_error
	# Set up basic configuration files and permissions for user
	arch_chroot "cp /etc/skel/.bashrc /home/${USER}"
	arch_chroot "chown -R ${USER}:users /home/${USER}"
	[[ -e ${MOUNTPOINT}/etc/sudoers ]] && sed -i '/%wheel ALL=(ALL) ALL/s/^#//' ${MOUNTPOINT}/etc/sudoers
}

run_mkinitcpio() 
{
	clear
	KERNEL=""

	arch_chroot "mkinitcpio -p linux" 2>>/tmp/.errlog
	check_for_error
}

######################################################################
##																	##
##            System and Partitioning Functions						##
##																	##
######################################################################

# Unmount partitions.
umount_partitions()
{
	MOUNTED=""
	MOUNTED=$(mount | grep "${MOUNTPOINT}" | awk '{print $3}' | sort -r)
	swapoff -a
  
	for i in ${MOUNTED[@]}; do
		umount $i >/dev/null 2>>/tmp/.errlog
	done
  
	check_for_error
}

# Revised to deal with partion sizes now being displayed to the user
confirm_mount()
{
    if [[ $(mount | grep $1) ]]; then   
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_MntStatusTitle " --infobox "$_MntStatusSucc" 0 0
		sleep 2
		PARTITIONS=$(echo $PARTITIONS | sed "s~${PARTITION} [0-9]*[G-M]~~" | sed "s~${PARTITION} [0-9]*\.[0-9]*[G-M]~~" | sed s~${PARTITION}$' -'~~)
		NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS - 1 ))
    else
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_MntStatusTitle " --infobox "$_MntStatusFail" 0 0
		sleep 2
		prep_menu
    fi
}

# This function does not assume that the formatted device is the Root installation device as 
# more than one device may be formatted. Root is set in the mount_partitions function.
select_device()
{
    DEVICE=""
    devices_list=$(lsblk -lno NAME,SIZE,TYPE | grep 'disk' | awk '{print "/dev/" $1 " " $2}' | sort -u);
    
    for i in ${devices_list[@]}; do
		DEVICE="${DEVICE} ${i}"
    done
    
    dialog --backtitle "$VERSION - ($ARCHI)" --title " $_DevSelTitle " --menu "$_DevSelBody" 0 0 4 ${DEVICE} 2>${ANSWER} || prep_menu
    DEVICE=$(cat ${ANSWER})
}

# Finds all available partitions according to type(s) specified and generates a list 
# of them. This also includes partitions on different devices.
find_partitions()
{
	PARTITIONS=""
	NUMBER_PARTITIONS=0	
	partition_list=$(lsblk -lno NAME,SIZE,TYPE | grep $INCLUDE_PART | sed 's/part$/\/dev\//g' | awk '{print $3$1 " " $2}' | sort -u)

    for i in ${partition_list}; do
        PARTITIONS="${PARTITIONS} ${i}"
        NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS + 1 ))
    done
    
    # Double-partitions will be counted due to counting sizes, so fix    
    NUMBER_PARTITIONS=$(( NUMBER_PARTITIONS / 2 ))

	# Deal with incorrect partitioning for main mounting function
	if [[ $NUMBER_PARTITIONS -lt 2 ]] ; then
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ErrTitle " --msgbox "$_PartErrBody" 0 0
		create_partitions
	fi
}

create_partitions()
{
	# Partitioning Menu
    dialog --backtitle "$VERSION - ($ARCHI)" --title " $_PrepPartDisk " --menu "$_PartToolBody" 0 0 4 \
	"cgdisk" "UEFI" \
	"fdisk"  "BIOS & UEFI" \
	"gdisk"  "UEFI" \
	"parted" "BIOS & UEFI" 2>${ANSWER}

	clear
	# If something selected
	if [[ $(cat ${ANSWER}) != "" ]]; then
		$(cat ${ANSWER}) ${DEVICE}
	fi
	
	prep_menu
}	

# Set static list of filesystems rather than on-the-fly. Partially as most require additional flags, and 
# partially because some don't seem to be viable.
select_filesystem()
{
	# prep variables
	fs_opts=""
	CHK_NUM=0

	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_FSTitle " --menu "$_FSBody" 0 0 4 \
	"$_FSSkip" "-" \
	"ext4" "mkfs.ext4 -q" \
	"ntfs" "mkfs.ntfs -q" \
	"vfat" "mkfs.vfat -F32" 2>${ANSWER}	
	
	case $(cat ${ANSWER}) in
		"$_FSSkip")	FILESYSTEM="$_FSSkip" ;;
		"ext4") 	FILESYSTEM="mkfs.ext4 -q"
					CHK_NUM=8
					fs_opts="data=journal data=writeback dealloc discard noacl noatime nobarrier nodelalloc"
					;;
		"ntfs") 	FILESYSTEM="mkfs.ntfs -q" ;;
					;;
		"vfat") 	FILESYSTEM="mkfs.vfat -F32" ;;
					;;
		*) 			prep_menu ;;
	esac
	
	# Warn about formatting!
	if [[ $FILESYSTEM != $_FSSkip ]]; then
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_FSTitle " --yesno "\n$FILESYSTEM $PARTITION\n\n" 0 0
		if [[ $? -eq 0 ]]; then
			${FILESYSTEM} ${PARTITION} >/dev/null 2>/tmp/.errlog
			check_for_error
		else
			select_filesystem
		fi
	fi
}
  
mount_partitions()
{

	# This subfunction allows for special mounting options to be applied for relevant fs's.
	# Seperate subfunction for neatness.
	mount_opts()
	{
		FS_OPTS=""
		echo "" > ${MOUNT_OPTS}
	
		for i in ${fs_opts}; do
			FS_OPTS="${FS_OPTS} ${i} - off"
		done

		dialog --backtitle "$VERSION - ($ARCHI)" --title " $(echo $FILESYSTEM | sed "s/.*\.//g" | sed "s/-.*//g") " --checklist "$_btrfsMntBody" 0 0 $CHK_NUM \
		$FS_OPTS 2>${MOUNT_OPTS}
	
		# Now clean up the file
		sed -i 's/ /,/g' ${MOUNT_OPTS}
		sed -i '$s/,$//' ${MOUNT_OPTS}

		# If mount options selected, confirm choice 
		if [[ $(cat ${MOUNT_OPTS}) != "" ]]; then
			dialog --backtitle "$VERSION - ($ARCHI)" --title " $_MntStatusTitle " --yesno "\n${_btrfsMntConfBody}$(cat ${MOUNT_OPTS})\n" 10 75
			[[ $? -eq 1 ]] && mount_opts
		fi 
	}

	# Subfunction to save repetition of code
	mount_current_partition()
	{
		# Make the mount directory
		mkdir -p ${MOUNTPOINT}${MOUNT} 2>/tmp/.errlog
		
		# Get mounting options for appropriate filesystems
		[[ $fs_opts != "" ]] && mount_opts
			
		# Use special mounting options if selected, else standard mount
		if [[ $(cat ${MOUNT_OPTS}) != "" ]]; then
			mount -o $(cat ${MOUNT_OPTS}) ${PARTITION} ${MOUNTPOINT}${MOUNT} 2>>/tmp/.errlog
		else
			mount ${PARTITION} ${MOUNTPOINT}${MOUNT} 2>>/tmp/.errlog
		fi
		
		check_for_error
		confirm_mount ${MOUNTPOINT}${MOUNT}
	}

 	####								####
	#### MOUNTING FUNCTION BEGINS HERE  ####
	####								####

	# prep variables
	MOUNT=""
	
	# Warn users that they CAN mount partitions without formatting them!
	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_PrepMntPart " --msgbox "$_WarnMount1 '$_FSSkip' $_WarnMount2" 0 0

	# Ensure partitions are unmounted (i.e. where mounted previously), and then list available partitions
	INCLUDE_PART='part'
    umount_partitions
	find_partitions
	
	# Identify and mount root
	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_PrepMntPart " --menu "$_SelRootBody" 0 0 7 ${PARTITIONS} 2>${ANSWER} || prep_menu
	PARTITION=$(cat ${ANSWER})
    ROOT_PART=${PARTITION}
   	
   	# Format with FS (or skip)
	select_filesystem
		
	# Make the directory and mount. 
	mount_current_partition

    # Extra Step for VFAT UEFI Partition. 
	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_PrepMntPart " --menu "$_SelUefiBody" 0 0 7 ${PARTITIONS} 2>${ANSWER} || prep_menu  
	PARTITION=$(cat ${ANSWER})
	UEFI_PART=${PARTITION}

	# If it is already a fat/vfat partition...
	if [[ $(fsck -N $PARTITION | grep fat) ]]; then
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_PrepMntPart " --yesno "$_FormUefiBody $PARTITION $_FormUefiBody2" 0 0 && mkfs.vfat -F32 ${PARTITION} >/dev/null 2>/tmp/.errlog
	else 
		mkfs.vfat -F32 ${PARTITION} >/dev/null 2>/tmp/.errlog
	fi
	check_for_error
		 
	# Inform users of the mountpoint options and consequences       
	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_PrepMntPart " --menu "$_MntUefiBody"  0 0 2 \
	"/boot" "systemd-boot"\
	"/boot/efi" "-" 2>${ANSWER}
	   
	[[ $(cat ${ANSWER}) != "" ]] && UEFI_MOUNT=$(cat ${ANSWER}) || prep_menu

	mkdir -p ${MOUNTPOINT}${UEFI_MOUNT} 2>/tmp/.errlog
	mount ${PARTITION} ${MOUNTPOINT}${UEFI_MOUNT} 2>>/tmp/.errlog
	check_for_error
	confirm_mount ${MOUNTPOINT}${UEFI_MOUNT}           
    
    # All other partitions
	while [[ $NUMBER_PARTITIONS > 0 ]]; do 
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_PrepMntPart " --menu "$_ExtPartBody" 0 0 7 "$_Done" $"-" ${PARTITIONS} 2>${ANSWER} || prep_menu 
		PARTITION=$(cat ${ANSWER})
             
		if [[ $PARTITION == $_Done ]]; then
			break;
		else
			MOUNT=""
			select_filesystem
                 
			# Ask user for mountpoint.
			MNT_EXAMPLES="/home\n/var"
			dialog --backtitle "$VERSION - ($ARCHI)" --title " $_PrepMntPart $PARTITON " --inputbox "$_ExtPartBody1$MNT_EXAMPLES\n" 0 0 "/" 2>${ANSWER} || prep_menu
			MOUNT=$(cat ${ANSWER})
                
			# loop while the mountpoint specified is incorrect (is only '/', is blank, or has spaces). 
			while [[ ${MOUNT:0:1} != "/" ]] || [[ ${#MOUNT} -le 1 ]] || [[ $MOUNT =~ \ |\' ]]; do
				# Warn user about naming convention
				dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ErrTitle " --msgbox "$_ExtErrBody" 0 0
				# Ask user for mountpoint again
				dialog --backtitle "$VERSION - ($ARCHI)" --title " $_PrepMntPart $PARTITON " --inputbox "$_ExtPartBody1$MNT_EXAMPLES\n" 0 0 "/" 2>${ANSWER} || prep_menu
				MOUNT=$(cat ${ANSWER})                     
			done

			# Create directory and mount.
			mount_current_partition
		fi
	done
}	

######################################################################
##																	##
##                    Installation Functions						##
##																	##
######################################################################	

install_base()
{
	clear
	pacstrap ${MOUNTPOINT} base base-devel 2>/tmp/.errlog
	check_for_error
	
	cp -f /etc/pacman.conf ${MOUNTPOINT}/etc/pacman.conf 2>>/tmp/.errlog
	check_for_error
}

install_bootloader()
{
    check_mount
    # Set the default PATH variable
    arch_chroot "PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl" 2>/tmp/.errlog
    check_for_error

    #Ensure again that efivarfs is mounted
	[[ -z $(mount | grep /sys/firmware/efi/efivars) ]] && mount -t efivarfs efivarfs /sys/firmware/efi/efivars

	arch_chroot "bootctl --path=${UEFI_MOUNT} install" 2>/tmp/.errlog
	check_for_error
				
	# Create default config files. First the loader
	echo -e "default  arch\ntimeout  5" > ${MOUNTPOINT}${UEFI_MOUNT}/loader/loader.conf 2>/tmp/.errlog
				
	# Second, the kernel conf files
	echo -e "title\tArch Linux\nlinux\t/vmlinuz-linux\ninitrd\t/initramfs-linux.img\noptions\troot=${bl_root} rw" > ${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/arch.conf
}
 
install_network_menu()
{
	# ntp not exactly wireless, but this menu is the best fit.
	install_wireless_packages()
	{
		WIRELESS_PACKAGES=""
		wireless_pkgs="dialog iw rp-pppoe wireless_tools wpa_actiond"
		
		for i in ${wireless_pkgs}; do
			WIRELESS_PACKAGES="${WIRELESS_PACKAGES} ${i} - on"
		done
		
		# If no wireless, uncheck wireless pkgs
		[[ $(lspci | grep -i "Network Controller") == "" ]] && WIRELESS_PACKAGES=$(echo $WIRELESS_PACKAGES | sed "s/ on/ off/g")
		
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_InstNMMenuPkg " --checklist "$_InstNMMenuPkgBody\n\n$_UseSpaceBar" 0 0 13 \
		$WIRELESS_PACKAGES \
		"ufw" "-" off \
		"gufw" "-" off \
		"ntp" "-" off \
		"b43-fwcutter" "Broadcom 802.11b/g/n" off \
		"bluez-firmware" "Broadcom BCM203x / STLC2300 Bluetooth" off \
		"ipw2100-fw" "Intel PRO/Wireless 2100" off \
		"ipw2200-fw" "Intel PRO/Wireless 2200" off \
		"zd1211-firmware" "ZyDAS ZD1211(b) 802.11a/b/g USB WLAN" off 2>${PACKAGES}
		
		if [[ $(cat ${PACKAGES}) != "" ]]; then
			clear
			pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
			check_for_error
		fi
	}

	install_cups()
	{
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_InstNMMenuCups " --checklist "$_InstCupsBody\n\n$_UseSpaceBar" 0 0 11 \
		"cups" "-" on \
		"cups-pdf" "-" off \
		"ghostscript" "-" on \
		"gsfonts" "-" on \
		"samba" "-" off 2>${PACKAGES}
		
		if [[ $(cat ${PACKAGES}) != "" ]]; then
			clear
			pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
			check_for_error
			
			if [[ $(cat ${PACKAGES} | grep "cups") != "" ]]; then
				dialog --backtitle "$VERSION - ($ARCHI)" --title " $_InstNMMenuCups " --yesno "$_InstCupsQ" 0 0
				if [[ $? -eq 0 ]]; then
					arch_chroot "systemctl enable org.cups.cupsd.service" 2>/tmp/.errlog
					check_for_error
					dialog --backtitle "$VERSION - ($ARCHI)" --title " $_InstNMMenuCups " --infobox "\n$_Done!\n\n" 0 0
					sleep 2
				fi
			fi
		fi
		
	}

	if [[ $SUB_MENU != "install_network_packages" ]]; then
	   SUB_MENU="install_network_packages"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 5 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

    dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - ($ARCHI)" --title " $_InstNMMenuTitle " --menu "$_InstNMMenuBody" 0 0 5 \
 	"1" "$_SeeWirelessDev" \
 	"2" "$_InstNMMenuPkg" \
 	"3" "$_InstNMMenuNM" \
 	"4" "$_InstNMMenuCups" \
 	"5" "$_Back" 2>${ANSWER}

    case $(cat ${ANSWER}) in
    "1") # Identify the Wireless Device 
        lspci -k | grep -i -A 2 "network controller" > /tmp/.wireless
        if [[ $(cat /tmp/.wireless) != "" ]]; then
           dialog --backtitle "$VERSION - ($ARCHI)" --title " $_WirelessShowTitle " --textbox /tmp/.wireless 0 0
        else
           dialog --backtitle "$VERSION - ($ARCHI)" --title " $_WirelessShowTitle " --msgbox "$_WirelessErrBody" 7 30
        fi
        ;;
    "2") install_wireless_packages
        ;;
	"3") install_nm
		;;
	"4") install_cups
		;;
	*) main_menu_online
        ;;
    esac
    
    install_network_menu
}

# Install xorg and input drivers. Also copy the xkbmap configuration file created earlier to the installed system
install_xorg_input() 
{
	echo "" > ${PACKAGES}

	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_InstGrMenuDS " --checklist "$_InstGrMenuDSBody\n\n$_UseSpaceBar" 0 0 12 \
	"wayland" "-" off \
	"xorg-server" "-" on \
	"xorg-server-common" "-" off \
	"xorg-server-utils" "-" on \
	"xorg-xinit" "-" on \
	"xorg-server-xwayland" "-" off \
	"xf86-input-evdev" "-" off \
	"xf86-input-joystick" "-" off \
	"xf86-input-keyboard" "-" on \
	"xf86-input-libinput" "-" off \
	"xf86-input-mouse" "-" on \
	"xf86-input-synaptics" "-" on 2>${PACKAGES}

	clear
	# If at least one package, install.
	if [[ $(cat ${PACKAGES}) != "" ]]; then
		pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
		check_for_error
	fi
  
	# now copy across .xinitrc for all user accounts
	user_list=$(ls ${MOUNTPOINT}/home/ | sed "s/lost+found//")
	for i in ${user_list}; do
		cp -f ${MOUNTPOINT}/etc/X11/xinit/xinitrc ${MOUNTPOINT}/home/$i/.xinitrc
		arch_chroot "chown -R ${i}:users /home/${i}"
	done

	install_graphics_menu
}

setup_graphics_card()
{
	# Save repetition
	install_intel()
	{
		pacstrap ${MOUNTPOINT} xf86-video-intel libva-intel-driver intel-ucode 2>/tmp/.errlog
		sed -i 's/MODULES=""/MODULES="i915"/' ${MOUNTPOINT}/etc/mkinitcpio.conf
			   
		# Intel microcode
		if [[ -e ${MOUNTPOINT}${UEFI_MOUNT}/loader/loader.conf ]]; then
			update=$(ls ${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/*.conf)
			for i in ${upgate}; do
				sed -i '/linux \//a initrd \/intel-ucode.img' ${i}
			done
		fi
	}

	# Main menu. Correct option for graphics card should be automatically highlighted.
	NVIDIA=""
	VB_MOD=""
	GRAPHIC_CARD=""
	INTEGRATED_GC="Intel"
	GRAPHIC_CARD=$(lspci | grep -i "vga" | sed 's/.*://' | sed 's/(.*//' | sed 's/^[ \t]*//')
	
	# Highlight menu entry depending on GC detected. Extra work is needed for NVIDIA
	if 	[[ $(echo $GRAPHIC_CARD | grep -i "nvidia") != "" ]]; then
		if [[ $(dmesg | grep -i 'chipset' | grep -i 'nvc\|nvd\|nve') != "" ]]; then HIGHLIGHT_SUB_GC=3
		else HIGHLIGHT_SUB_GC=2
		fi
	
	# All non-NVIDIA cards / virtualisation
	elif [[ $(echo $GRAPHIC_CARD | grep -i 'intel\|lenovo') != "" ]]; then HIGHLIGHT_SUB_GC=1
	elif [[ $(echo $GRAPHIC_CARD | grep -i 'virtualbox') != "" ]]; then HIGHLIGHT_SUB_GC=4
	else HIGHLIGHT_SUB_GC=5
	fi
	
	dialog --default-item ${HIGHLIGHT_SUB_GC} --backtitle "$VERSION - ($ARCHI)" --title " $_GCtitle " \
    --menu "$GRAPHIC_CARD\n" 0 0 10 \
	"1" $"xf86-video-intel" \
	"2" $"xf86-video-nouveau (+ $INTEGRATED_GC)" \
	"3" $"Nvidia (+ $INTEGRATED_GC)" \
	"4" $"virtualbox-guest-dkms" \
	"5" "$_GCUnknOpt / xf86-video-fbdev" 2>${ANSWER}

	case $(cat ${ANSWER}) in
        "1") # Intel
			install_intel
             ;;
        "2") # Nouveau / NVIDIA
			install_intel
			pacstrap ${MOUNTPOINT} xf86-video-nouveau 2>/tmp/.errlog
            sed -i 's/MODULES=""/MODULES="nouveau"/' ${MOUNTPOINT}/etc/mkinitcpio.conf       
             ;;
        "3") # NVIDIA-GF
			install_intel
			arch_chroot "pacman -Rdds --noconfirm mesa-libgl mesa"
 
 			# Set NVIDIA driver(s) to install depending on installed kernel(s)
			([[ -e ${MOUNTPOINT}/boot/initramfs-linux.img ]] || [[ -e ${MOUNTPOINT}/boot/initramfs-linux-grsec.img ]] || [[ -e ${MOUNTPOINT}/boot/initramfs-linux-zen.img ]]) && NVIDIA="nvidia"
			[[ -e ${MOUNTPOINT}/boot/initramfs-linux-lts.img ]] && NVIDIA="$NVIDIA nvidia-lts"

			clear
			pacstrap ${MOUNTPOINT} ${NVIDIA} nvidia-libgl nvidia-utils pangox-compat nvidia-settings 2>/tmp/.errlog
            NVIDIA_INST=1
             ;;
        "4") # VirtualBox
			VB_MOD="linux-headers"
			dialog --backtitle "$VERSION - ($ARCHI)" --title "$_VBoxInstTitle" --msgbox "$_VBoxInstBody" 0 0
            clear
 			
            pacstrap ${MOUNTPOINT} virtualbox-guest-utils virtualbox-guest-dkms $VB_MOD 2>/tmp/.errlog
			umount -l /mnt/dev
 
            # Load modules and enable vboxservice.
            arch_chroot "modprobe -a vboxguest vboxsf vboxvideo"  
            arch_chroot "systemctl enable vboxservice"
            echo -e "vboxguest\nvboxsf\nvboxvideo" > ${MOUNTPOINT}/etc/modules-load.d/virtualbox.conf
             ;;
       "10") # Generic / Unknown
			pacstrap ${MOUNTPOINT} xf86-video-fbdev 2>/tmp/.errlog
             ;;
          *) install_graphics_menu
             ;;
    esac
    check_for_error

	# Create a basic xorg configuration file for NVIDIA proprietary drivers where installed
	# if that file does not already exist.
	if [[ $NVIDIA_INST == 1 ]] && [[ ! -e ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf ]]; then
		echo "Section "\"Device"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
		echo "        Identifier "\"Nvidia Card"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
		echo "        Driver "\"nvidia"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
		echo "        VendorName "\"NVIDIA Corporation"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
		echo "        Option "\"NoLogo"\" "\"true"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
		echo "        #Option "\"UseEDID"\" "\"false"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
		echo "        #Option "\"ConnectedMonitor"\" "\"DFP"\"" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
		echo "        # ..." >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
		echo "EndSection" >> ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
	fi

	# Where NVIDIA has been installed allow user to check and amend the file
	if [[ $NVIDIA_INST == 1 ]]; then
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_NvidiaConfTitle " --msgbox "$_NvidiaConfBody" 0 0
		vi ${MOUNTPOINT}/etc/X11/xorg.conf.d/20-nvidia.conf
	fi

	install_graphics_menu
}


install_de_wm()
{
	# Only show this information box once
	if [[ $SHOW_ONCE -eq 0 ]]; then
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_InstDETitle " --msgbox "$_DEInfoBody" 0 0
		SHOW_ONCE=1
	fi

	# DE/WM Menu
	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_InstDETitle " --checklist "$_InstDEBody $_UseSpaceBar" 0 0 12 \
	"budgie-desktop" "-" off \
	"cinnamon" "-" off \
	"deepin" "-" off \
	"deepin-extra" "-" off \
	"enlightenment + terminology" "-" off \
	"gnome-shell" "-" off \
	"gnome" "-" off \
	"gnome-extra" "-" off \
	"plasma-desktop" "-" off \
	"plasma" "-" off \
	"kde-applications" "-" off \
	"lxde" "-" off \
	"lxqt + oxygen-icons" "-" off \
	"mate" "-" off \
	"mate-extra" "-" off \
	"mate-gtk3" "-" off \
	"mate-extra-gtk3" "-" off \
	"xfce4" "-" off \
	"xfce4-goodies" "-" off \
	"awesome + vicious" "-" off \
	"fluxbox + fbnews" "-" off \
	"i3-wm + i3lock + i3status" "-" off \
	"icewm + icewm-themes" "-" off \
	"openbox + openbox-themes" "-" off \
	"pekwm + pekwm-themes" "-" off \
	"windowmaker" "-" off 2>${PACKAGES}

	# If something has been selected, install
	if [[ $(cat ${PACKAGES}) != "" ]]; then
		clear
		sed -i 's/+\|\"//g' ${PACKAGES}
		pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
		check_for_error
		
		# Clear the packages file for installation of "common" packages
		echo "" > ${PACKAGES}

		# Offer to install various "common" packages.
		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_InstComTitle " --checklist "$_InstComBody $_UseSpaceBar" 0 50 14 \
		"bash-completion" "-" on \
		"gamin" "-" on \
		"gksu" "-" on \
		"gnome-icon-theme" "-" on \
		"gnome-keyring" "-" on \
		"gvfs" "-" on \
		"gvfs-afc" "-" on \
		"gvfs-smb" "-" on \
		"polkit" "-" on \
		"poppler" "-" on \
		"python2-xdg" "-" on \
		"ntfs-3g" "-" on \
		"ttf-dejavu" "-" on \
		"xdg-user-dirs" "-" on \
		"xdg-utils" "-" on \
		"xterm" "-" on 2>${PACKAGES}

		# If at least one package, install.
		if [[ $(cat ${PACKAGES}) != "" ]]; then
			clear
			pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
			check_for_error
		fi
	fi
}

# Display Manager
install_dm()
{
	# Save repetition of code
	enable_dm()
	{
		arch_chroot "systemctl enable $(cat ${PACKAGES})" 2>/tmp/.errlog
		check_for_error
		DM=$(cat ${PACKAGES})
		DM_ENABLED=1
	}

	if [[ $DM_ENABLED -eq 0 ]]; then
		# Prep variables
		echo "" > ${PACKAGES}
		dm_list="gdm lxdm lightdm sddm"
		DM_LIST=""
		DM_INST=""

		# Generate list of DMs installed with DEs, and a list for selection menu
		for i in ${dm_list}; do
			[[ -e ${MOUNTPOINT}/usr/bin/${i} ]] && DM_INST="${DM_INST} ${i}"
			DM_LIST="${DM_LIST} ${i} -"
		done

		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_DmChTitle " --menu "$_AlreadyInst$DM_INST\n\n$_DmChBody" 0 0 4 \
		${DM_LIST} 2>${PACKAGES}
		clear
		
		# If a selection has been made, act
		if [[ $(cat ${PACKAGES}) != "" ]]; then
			# check if selected dm already installed. If so, enable and break loop.
			for i in ${DM_INST}; do
				if [[ $(cat ${PACKAGES}) == ${i} ]]; then
					enable_dm
					break;
				fi
			done
		
			# If no match found, install and enable DM	
			if [[ $DM_ENABLED -eq 0 ]]; then
				# Where lightdm selected, add gtk greeter package
				sed -i 's/lightdm/lightdm lightdm-gtk-greeter/' ${PACKAGES}
				pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
				
				# Where lightdm selected, now remove the greeter package
				sed -i 's/lightdm-gtk-greeter//' ${PACKAGES}
				enable_dm
			fi
		fi
	fi

	# Show after successfully installing or where attempting to repeat when already completed.
	[[ $DM_ENABLED -eq 1 ]] && dialog --backtitle "$VERSION - ($ARCHI)" --title " $_DmChTitle " --msgbox "$_DmDoneBody" 0 0       
}

# Network Manager
install_nm() {

# Save repetition of code
enable_nm() {
	if [[ $(cat ${PACKAGES}) == "NetworkManager" ]]; then
		arch_chroot "systemctl enable NetworkManager.service && systemctl enable NetworkManager-dispatcher.service" >/tmp/.symlink 2>/tmp/.errlog
	else
		arch_chroot "systemctl enable $(cat ${PACKAGES})" 2>/tmp/.errlog
	fi
	
	check_for_error
	NM_ENABLED=1
}

	if [[ $NM_ENABLED -eq 0 ]]; then
		# Prep variables
		echo "" > ${PACKAGES}
		nm_list="connman CLI dhcpcd CLI netctl CLI NetworkManager GUI wicd GUI"
		NM_LIST=""
		NM_INST=""

		# Generate list of DMs installed with DEs, and a list for selection menu
		for i in ${nm_list}; do
			[[ -e ${MOUNTPOINT}/usr/bin/${i} ]] && NM_INST="${NM_INST} ${i}"
			NM_LIST="${NM_LIST} ${i}"
		done

		# Remove netctl from selectable list as it is a PITA to configure via arch_chroot
		NM_LIST=$(echo $NM_LIST | sed "s/netctl CLI//")

		dialog --backtitle "$VERSION - ($ARCHI)" --title " $_InstNMTitle " --menu "$_AlreadyInst $NM_INST\n$_InstNMBody" 0 0 4 \
		${NM_LIST} 2> ${PACKAGES}
		clear

		# If a selection has been made, act
		if [[ $(cat ${PACKAGES}) != "" ]]; then
		
			# check if selected nm already installed. If so, enable and break loop.
			for i in ${NM_INST}; do
				[[ $(cat ${PACKAGES}) == ${i} ]] && enable_nm && break
			done
			            
			# If no match found, install and enable NM	
			if [[ $NM_ENABLED -eq 0 ]]; then
			 
				# Where networkmanager selected, add network-manager-applet
				sed -i 's/NetworkManager/networkmanager network-manager-applet/g' ${PACKAGES}
				pacstrap ${MOUNTPOINT} $(cat ${PACKAGES}) 2>/tmp/.errlog
			
				# Where networkmanager selected, now remove network-manager-applet
				sed -i 's/networkmanager network-manager-applet/NetworkManager/g' ${PACKAGES}
				enable_nm
			fi
		fi
	fi
	
	# Show after successfully installing or where attempting to repeat when already completed.
	[[ $NM_ENABLED -eq 1 ]] && dialog --backtitle "$VERSION - ($ARCHI)" --title " $_InstNMTitle " --msgbox "$_InstNMErrBody" 0 0


}

security_menu()
{
	if [[ $SUB_MENU != "security_menu" ]]; then
	   SUB_MENU="security_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 4 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

    dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - ($ARCHI)" --title " $_SecMenuTitle " --menu "$_SecMenuBody" 0 0 4 \
 	"1" "$_SecJournTitle" \
	"2" "$_SecCoreTitle" \
	"3" "$_SecKernTitle" \
	"4" "$_Back" 2>${ANSWER}

	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") # systemd-journald
			dialog --backtitle "$VERSION - ($ARCHI)" --title " $_SecJournTitle " --menu "$_SecJournBody" 0 0 7 \
			"$_Edit" "/etc/systemd/journald.conf" \
			"10M" "SystemMaxUse=10M" \
			"20M" "SystemMaxUse=20M" \
			"50M" "SystemMaxUse=50M" \
			"100M" "SystemMaxUse=100M" \
			"200M" "SystemMaxUse=200M" \
			"$_Disable" "Storage=none" 2>${ANSWER}

			if [[ $(cat ${ANSWER}) != "" ]]; then
				if  [[ $(cat ${ANSWER}) == "$_Disable" ]]; then
					sed -i "s/#Storage.*\|Storage.*/Storage=none/g" ${MOUNTPOINT}/etc/systemd/journald.conf
					sed -i "s/SystemMaxUse.*/#&/g" ${MOUNTPOINT}/etc/systemd/journald.conf
					dialog --backtitle "$VERSION - ($ARCHI)" --title " $_SecJournTitle " --infobox "\n$_Done!\n\n" 0 0
					sleep 2
				elif [[ $(cat ${ANSWER}) == "$_Edit" ]]; then
					nano ${MOUNTPOINT}/etc/systemd/journald.conf
				else
					sed -i "s/#SystemMaxUse.*\|SystemMaxUse.*/SystemMaxUse=$(cat ${ANSWER})/g" ${MOUNTPOINT}/etc/systemd/journald.conf
					sed -i "s/Storage.*/#&/g" ${MOUNTPOINT}/etc/systemd/journald.conf
					dialog --backtitle "$VERSION - ($ARCHI)" --title " $_SecJournTitle " --infobox "\n$_Done!\n\n" 0 0
					sleep 2
				fi
			fi
			;;
		"2") # core dump
			 dialog --backtitle "$VERSION - ($ARCHI)" --title " $_SecCoreTitle " --menu "$_SecCoreBody" 0 0 2 \
			"$_Disable" "Storage=none" "$_Edit" "/etc/systemd/coredump.conf" 2>${ANSWER}
			
			if [[ $(cat ${ANSWER}) == "$_Disable" ]]; then
				sed -i "s/#Storage.*\|Storage.*/Storage=none/g" ${MOUNTPOINT}/etc/systemd/coredump.conf
				dialog --backtitle "$VERSION - ($ARCHI)" --title " $_SecCoreTitle " --infobox "\n$_Done!\n\n" 0 0
				sleep 2
			elif [[ $(cat ${ANSWER}) == "$_Edit" ]]; then
				nano ${MOUNTPOINT}/etc/systemd/coredump.conf
			fi
          ;;
        "3") # Kernel log access 
			dialog --backtitle "$VERSION - ($ARCHI)" --title " $_SecKernTitle " --menu "\nKernel logs may contain information an attacker can use to identify and exploit kernel vulnerabilities, including sensitive memory addresses.\n\nIf systemd-journald logging has not been disabled, it is possible to create a rule in /etc/sysctl.d/ to disable access to these logs unless using root privilages (e.g. via sudo).\n" 0 0 2 \
			"$_Disable" "kernel.dmesg_restrict = 1" "$_Edit" "/etc/systemd/coredump.conf.d/custom.conf" 2>${ANSWER}
			
			case $(cat ${ANSWER}) in
			"$_Disable") 	echo "kernel.dmesg_restrict = 1" > ${MOUNTPOINT}/etc/sysctl.d/50-dmesg-restrict.conf
							dialog --backtitle "$VERSION - ($ARCHI)" --title " $_SecKernTitle " --infobox "\n$_Done!\n\n" 0 0
							sleep 2 ;;
			"$_Edit") 		[[ -e ${MOUNTPOINT}/etc/sysctl.d/50-dmesg-restrict.conf ]] && nano ${MOUNTPOINT}/etc/sysctl.d/50-dmesg-restrict.conf \
							|| dialog --backtitle "$VERSION - ($ARCHI)" --title " $_SeeConfErrTitle " --msgbox "$_SeeConfErrBody1" 0 0 ;;
			esac
             ;;
          *) main_menu_online
			;;
    esac
    
    security_menu
}

######################################################################
##																	##
##                 Main Interfaces       							##
##																	##
######################################################################

# Greet the user when first starting the installer
greeting()
{
	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_WelTitle $VERSION " --msgbox "$_WelBody" 0 0	
}

# Preparation
prep_menu()
{
	if [[ $SUB_MENU != "prep_menu" ]]; then
		SUB_MENU="prep_menu"
		HIGHLIGHT_SUB=1
	else
		if [[ $HIGHLIGHT_SUB != 7 ]]; then
			HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
		fi
	fi
	
	dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - ($ARCHI)" --title " $_PrepMenuTitle " --menu "$_PrepMenuBody" 0 0 3 \
	"1" "$_PrepPartDisk" \
	"2" "$_PrepMntPart" \
	"3" "$_Back" 2>${ANSWER}

    HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") umount_partitions
             select_device
             create_partitions
             ;;
        "2") mount_partitions
             ;;        
          *) main_menu_online
             ;;
    esac
    
    prep_menu  	
	
}

# Base Installation
install_base_menu()
{
	if [[ $SUB_MENU != "install_base_menu" ]]; then
	   SUB_MENU="install_base_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 5 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

	dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - ($ARCHI)" --title " $_InstBsMenuTitle " --menu "$_InstBseMenuBody" 0 0 5 \
 	"1"	"$_PrepMirror" \
 	"2" "$_PrepPacKey" \
 	"3" "$_InstBse" \
	"4" "$_InstBootldr" \
	"5" "$_Back" 2>${ANSWER}	
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
	"1") configure_mirrorlist
		;;
	"2") clear
		 pacman-key --init
		 pacman-key --populate archlinux
		 pacman-key --refresh-keys
		;;
	"3") install_base
		;;
	"4") install_bootloader
		;;
	*) main_menu_online
		;;
	esac
    
	install_base_menu 	
}

# Base Configuration
config_base_menu()
{
	# Set the default PATH variable
    arch_chroot "PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/core_perl" 2>/tmp/.errlog
	check_for_error
	
	if [[ $SUB_MENU != "config_base_menu" ]]; then
	   SUB_MENU="config_base_menu"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 8 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

    dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - ($ARCHI)" --title " $_ConfBseMenuTitle " --menu "$_ConfBseBody" 0 0 8 \
 	"1" "$_ConfBseFstab" \
	"2" "$_ConfBseHost" \
	"3" "$_ConfBseSysLoc" \
	"4" "$_ConfBseTimeHC" \
	"5" "$_ConfUsrRoot" \
	"6" "$_ConfUsrNew" \
	"7" "$_MMRunMkinit" \
	"8" "$_Back" 2>${ANSWER}	
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") generate_fstab 
             ;;
        "2") set_hostname
             ;;
        "3") set_locale
             ;;        
        "4") set_timezone
			 set_hw_clock
             ;;
		"5") set_root_password 
			;;
		"6") create_new_user
			;;
		"7") run_mkinitcpio
			;;
          *) main_menu_online
			;;
    esac
    
    config_base_menu
}

install_graphics_menu()
{
	if [[ $SUB_MENU != "install_graphics_menu" ]]; then
		SUB_MENU="install_graphics_menu"
		HIGHLIGHT_SUB=1
	else
		if [[ $HIGHLIGHT_SUB != 6 ]]; then
			HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
		fi
	fi

    dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - ($ARCHI)" --title " $_InstGrMenuTitle " --menu "$_InstGrMenuBody" 0 0 6 \
 	"1" "$_InstGrMenuDS" \
	"2" "$_InstGrMenuDD" \
	"3" "$_InstGrMenuGE" \
	"4" "$_InstGrMenuDM" \
	"5"	"$_PrepKBLayout" \
	"6" "$_Back" 2>${ANSWER}

	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") install_xorg_input
			;;
		"2") setup_graphics_card 
             ;;
        "3") install_de_wm
             ;;
        "4") install_dm
             ;;
		"5") set_xkbmap
			;;
          *) main_menu_online
			;;
    esac
    
    install_graphics_menu
}

# Install Accessibility Applications
install_acc_menu() {

	echo "" > ${PACKAGES}

	dialog --backtitle "$VERSION - ($ARCHI)" --title " $_InstAccTitle " --checklist "$_InstAccBody" 0 0 15 \
	"accerciser" "-" off \
	"at-spi2-atk" "-" off \
	"at-spi2-core" "-" off \
	"brltty" "-" off \
	"caribou" "-" off \
	"dasher" "-" off \
	"espeak" "-" off \
	"espeakup" "-" off \
	"festival" "-" off \
	"java-access-bridge" "-" off \
	"java-atk-wrapper" "-" off \
	"julius" "-" off \
	"orca" "-" off \
	"qt-at-spi" "-" off \
	"speech-dispatcher" "-" off 2>${PACKAGES}
	
	clear
	# If something has been selected, install
	if [[ $(cat ${PACKAGES}) != "" ]]; then
		pacstrap ${MOUNTPOINT} ${PACKAGES} 2>/tmp/.errlog
		check_for_error
	fi
	
	install_multimedia_menu

}


edit_configs() 
{
	# Clear the file variables
	FILE=""
	user_list=""
	
	if [[ $SUB_MENU != "edit configs" ]]; then
	   SUB_MENU="edit configs"
	   HIGHLIGHT_SUB=1
	else
	   if [[ $HIGHLIGHT_SUB != 12 ]]; then
	      HIGHLIGHT_SUB=$(( HIGHLIGHT_SUB + 1 ))
	   fi
	fi

   dialog --default-item ${HIGHLIGHT_SUB} --backtitle "$VERSION - ($ARCHI)" --title " $_SeeConfOptTitle " --menu "$_SeeConfOptBody" 0 0 11 \
   "1" "/etc/locale.conf" \
   "2" "/etc/hostname" \
   "3" "/etc/hosts" \
   "4" "/etc/sudoers" \
   "5" "/etc/mkinitcpio.conf" \
   "6" "/etc/fstab" \
   "7" "grub/syslinux/systemd-boot" \
   "8" "lxdm/lightdm/sddm" \
   "9" "/etc/pacman.conf" \
   "10" "~/.xinitrc" \
   "11" "$_Back" 2>${ANSWER}
	
	HIGHLIGHT_SUB=$(cat ${ANSWER})
	case $(cat ${ANSWER}) in
        "1") [[ -e ${MOUNTPOINT}/etc/locale.conf ]] && FILE="${MOUNTPOINT}/etc/locale.conf" 
             ;;
        "2") [[ -e ${MOUNTPOINT}/etc/hostname ]] && FILE="${MOUNTPOINT}/etc/hostname"
             ;;
        "3") [[ -e ${MOUNTPOINT}/etc/hosts ]] && FILE="${MOUNTPOINT}/etc/hosts"
             ;;
        "4") [[ -e ${MOUNTPOINT}/etc/sudoers ]] && FILE="${MOUNTPOINT}/etc/sudoers"
             ;;
        "5") [[ -e ${MOUNTPOINT}/etc/mkinitcpio.conf ]] && FILE="${MOUNTPOINT}/etc/mkinitcpio.conf"
             ;;
        "6") [[ -e ${MOUNTPOINT}/etc/fstab ]] && FILE="${MOUNTPOINT}/etc/fstab"
             ;;
        "7") files=$(ls ${MOUNTPOINT}${UEFI_MOUNT}/loader/entries/*.conf)
				for i in ${files}; do
					FILE="$FILE ${i}"
				done
			 fi
            ;;
        "8") [[ -e ${MOUNTPOINT}/etc/lxdm/lxdm.conf ]] && FILE="${MOUNTPOINT}/etc/lxdm/lxdm.conf" 
			  [[ -e ${MOUNTPOINT}/etc/lightdm/lightdm.conf ]] && FILE="${MOUNTPOINT}/etc/lightdm/lightdm.conf"
              [[ -e ${MOUNTPOINT}/etc/sddm.conf ]] && FILE="${MOUNTPOINT}/etc/sddm.conf"
            ;;
        "9") [[ -e ${MOUNTPOINT}/etc/pacman.conf ]] && FILE="${MOUNTPOINT}/etc/pacman.conf"
			;;
		"10") user_list=$(ls ${MOUNTPOINT}/home/ | sed "s/lost+found//")
			  for i in ${user_list}; do
				[[ -e ${MOUNTPOINT}/home/$i/.xinitrc ]] && FILE="$FILE ${MOUNTPOINT}/home/$i/.xinitrc"
			  done
			;;
         *) main_menu_online
            ;;
     esac
     
	[[ $FILE != "" ]] && vi $FILE \
	|| dialog --backtitle "$VERSION - ($ARCHI)" --title " $_ErrTitle " --msgbox "$_SeeConfErrBody" 0 0
	
	edit_configs
}

main_menu_online()
{
	if [[ $HIGHLIGHT != 9 ]]; then
		HIGHLIGHT=$(( HIGHLIGHT + 1 ))
	fi
	
    dialog --default-item ${HIGHLIGHT} --backtitle "$VERSION - ($ARCHI)" --title " $_MMTitle " \
    --menu "$_MMBody" 0 0 8 \
 	"1" "$_PrepMenuTitle" \
	"2" "$_InstBsMenuTitle" \
	"3" "$_ConfBseMenuTitle" \
	"4" "$_InstGrMenuTitle" \
	"5" "$_InstNMMenuTitle" \
    "6" "$_SecMenuTitle" \
    "7" "$_SeeConfOptTitle" \
	"8" "$_Done" 2>${ANSWER}

    HIGHLIGHT=$(cat ${ANSWER})
    
    # Depending on the answer, first check whether partition(s) are mounted and whether base has been installed
    if [[ $(cat ${ANSWER}) -eq 2 ]]; then
		check_mount
    fi

    if [[ $(cat ${ANSWER}) -ge 3 ]] && [[ $(cat ${ANSWER}) -le 7 ]]; then
		check_mount
		check_base
    fi
    
    case $(cat ${ANSWER}) in
        "1") prep_menu 
             ;;
        "2") install_base_menu
             ;;
        "3") config_base_menu
             ;;          
        "4") install_graphics_menu
             ;;
        "5") install_network_menu
			;;
        "6") security_menu
			;;
        "7") edit_configs
             ;;            
          *) dialog --backtitle "$VERSION - ($ARCHI)" --yesno "$_CloseInstBody" 0 0
          
             if [[ $? -eq 0 ]]; then
                umount_partitions
                clear
                exit 0
             else
                main_menu_online
             fi
             
             ;;
    esac
    
    main_menu_online 
    
}

######################################################################
##																	##
##                        Execution     							##
##																	##
######################################################################
id_system
select_language
check_requirements
greeting
	while true; do
		main_menu_online      
    done
